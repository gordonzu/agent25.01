#ifndef AGENT_H
#define AGENT_H

// ai is generating code that uses shared pointers for the function ptr and the vectors
// ai is also ai is now changing the location pair from a null pointer to an object with -1 locations in function add_object
// replace all raw for loops

#include <functional>
#include <string>
#include <random>
#include <iostream>
#include <utility>
#include <vector>
#include <map>

const std::pair<int, int> loc_A(0, 0);
const std::pair<int, int> loc_B(1, 0);

class Object {
public:
    virtual ~Object() = default;

    virtual std::string to_string() const {
        return "<" + std::string(typeid(*this).name()) + ">";
    }

    virtual bool is_alive() {
        return alive;
    }

    std::pair<int, int> location;
    bool alive = false;
};


class Agent: public Object {
public:
    using Percept = std::pair<std::pair<int, int>, std::string>;
    using Program = std::function<std::string(Percept)>;

    explicit Agent(Program program = nullptr) {
        if (!program) {
            std::cout << "Can't find valid program type for Agent, falling back to default." << std::endl;

            program = [](Percept percept) {
                std::cout << "Percept=(" << percept.first.first << ","
                          << percept.first.second << ","
                          << percept.second << "; action? ";
                std::string action;
                std::getline(std::cin, action);
                return action;
            };
        }
        this->program = program;
    }

    std::string execute(Percept percept) {
        return program(percept);
    }

    int performance = 0;
    Program program;
};

class Environment {
public:
    Environment() = default;
    virtual ~Environment() = default;

    virtual std::pair<std::pair<int,int>, std::string> percept(Agent* agent) = 0;

    virtual void execute_action(Agent* agent, const std::string& action) = 0;

    virtual void exogenous_change() {};

    virtual std::vector<std::type_info> thingClasses() const {
        return std::vector<std::type_info>();
    }

    std::vector<Object*> list_things_at(const std::pair<int, int>& location,
                                      const std::type_info& tclass = typeid(Object)) {
        std::vector<Object*> result;
        for (Object* object : objects) {
            Agent* agent = dynamic_cast<Agent*>(object);
            if (agent && agent->location == location &&
                typeid(*object) == tclass) {
                result.push_back(object);
            }
        }
        return result;
    }

    bool some_objects_at(const std::pair<int, int>& location,
                     const std::type_info& tclass = typeid(Object)) {
        return !list_things_at(location, tclass).empty();
    }

    bool is_done() {
        return !std::any_of(agents.begin(), agents.end(),
                           [](Agent* a) { return a->is_alive(); });
    }

    void step() {
        if (!is_done()) {
            std::vector<std::string> actions;
            for (Agent* a : agents) {
                if (a->is_alive()) {
                    actions.push_back(a->program(percept(a)));
                } else {
                    actions.push_back("");
                }
            }
            for (size_t i = 0; i < agents.size(); ++i) {
                execute_action(agents[i], actions[i]);
            }
            exogenous_change();
        }
    }

    virtual std::pair<int, int> default_location(Object* obj) {
        return std::make_pair(0, 0);
    }

    void add_object(Object* obj, std::pair<int, int>* location = nullptr) {
        if (std::find(objects.begin(), objects.end(), obj) != objects.end()) {
            std::cout << "Object exists." << "\n";
            return;
        }

        Agent* agent = dynamic_cast<Agent*>(obj);
        if (agent) {
            agent->location = location ? *location : default_location(obj);
            agent-> performance = 0;
        }
        agents.push_back(agent);
    }

    void run(int steps = 1000) {
        for (int i = 0; i < steps; ++i) {
            if (is_done()) return;
            step();
        }
    }

    void delete_object(Object* object) {
        auto it = std::find(objects.begin(), objects.end(), object);
        if (it != objects.end()) {
            objects.erase(it);
            auto agentIt = std::find(agents.begin(), agents.end(),
                                   dynamic_cast<Agent*>(object));
            if (agentIt != agents.end()) {
                agents.erase(agentIt);
            }
        }
    }

protected:
    std::vector<Object*> objects;
    std::vector<Agent*> agents;
};

class TrivialVacuumEnvironment: public Environment {
public:
    TrivialVacuumEnvironment() {
        std::vector<std::string> choices = {"Clean", "Dirty"};
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 1);

        status[loc_A] = choices[dis(gen)];
        status[loc_B] = choices[dis(gen)];
    }

    std::pair<std::pair<int,int>, std::string> percept(Agent* agent) override {
        return std::make_pair(agent->location, status[agent->location]);
    }

    void execute_action(Agent* agent, const std::string& action) override {
        if (action == "Right") {
            agent->location = loc_B;
            agent->performance -= 1;
        } else if (action == "Left") {
            agent->location = loc_A;
            agent->performance -= 1;
        } else if (action == "Suck") {
            if (status[agent->location] == "Dirty") {
                agent->performance += 10;
            }
            status[agent->location] = "Clean";
        }
    }

    std::map<std::pair<int, int>, std::string> status;
};

Agent::Program RandomAgentProgram(const std::vector<std::string>& actions) {
    return [actions](const auto&) {
        static std::random_device rd;
        static std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, actions.size() - 1);
        return actions[dis(gen)];
    };
}

Agent* RandomVacuumAgent() {
    std::vector<std::string> actions = {"Right", "Left", "Suck", "NoOp"};
    return new Agent(RandomAgentProgram(actions));
}

Agent* ReflexVacuumAgent() {
    auto program = [](const std::pair<std::pair<int, int>, std::string>& percept) {
        auto location = percept.first;
        auto status = percept.second;

        if (status == "Dirty") {
            return std::string("Suck");
        }
        else if (location == loc_A) {
            return std::string("Right");
        }
        else if (location == loc_B) {
            return std::string("Left");
        }
        return std::string("NoOp");
    };
    return new Agent(program);
}

std::string print(std::map<std::pair<int, int>, std::string> rows) {
    std::string str;
    for (auto& row : rows) {
        str = "{(" + std::to_string(row.first.first);
        str += ", " + std::to_string(row.first.second);
        str += "): '" + row.second + "', ";
    }

    str.pop_back();
    str.append("}");
    return str;
}

#endif
